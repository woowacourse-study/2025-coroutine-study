# Chapter1 스레드 기반 작업의 한계와 코루틴의 등장

## 1.1 JVM 프로세스와 스레드

- JVM의 프로세스는 기본적으로 메인 스레드를 단일 스레드로 해서 실행되며 메인 스레드가 종료되면 종료되는 특징을 가짐
    - 만약 멀티 스레드 환경에서 사용자 스레드가 여러 개라면 메인 스레드에서 예외가 발생해 전파되더라도 프로세스는 강제 종료 되지 않음
    

## 1.2  단일 스레드의 한계와 멀티 스레드 프로그래밍

- 단일 스레드 에플리케이션 : 스레드 하나만 사용해 실행되는 애플리케이션

### 1.2.1 단일 스레드 애플리케이션의 한계

스레드는 하나의 작업을 수행할 때 다른 작업을 동시에 수행하지 못함

메인 스레드 하나만 사용하는 애플리케이션은 하나의 작업이 오래 걸리면 다른 작업을 전혀 할 수가 없게 됨에 따라 응답성에 문제가 생길 수 있음

→ 단일 스레드만 사용해 작업하면 해야 할 작업이 다른 작업에 의해 방해받거나 작업 속도가 느려질 수 있음

### 1.2.2 멀티 스레드 프로그래밍을 통한 단일 스레드의 한계 극복

- 멀티 스레드 프로그래밍 : 스레드를 여러 개 사용해 작업을 처리하는 프로그래밍 기법으로
    - 프로세스는 멀티 스레드 프로그래밍을 통해 여러 개의 스레드로 작업
    
    즉, 각각의 스레드가 한 번에 하나의 작업을 처리할 수 있으므로 여러 작업을 동시에 처리하는 것이 가능
    

- 안드로이드에서는 멀티 스레드 프로그래밍을 통해 메인 스레드 대신 별도 스레드가 처리할 수 있도록 만들어 이 문제를 해결
    - 메인 스레드에 오래 걸리는 작업이 요청됐을 때 오래 걸리는 작업을 백그라운드 스레드에서 처리하도록 만들면 UI가 멈추거나 사용자 입력을 받지 못하는 현상을 방지할 수 있음
    - 서버사이드에서도 오래 걸리는 작업이 요청됐을 때 작업을 스레드 간에 독립적인 작은 작업으로 나눈 후 각 작업을 서로 다른 스레드에서 실행되도록 하면 응답 속도를 높일 수 있음
    
    ( 모든 작업을 작은 단위로 나눠서 병렬로 실행할 수 있는 것은 아님. 작은 작업 간의 독립성이 있을 때만 병렬로 실행 가능)
    
    : 병렬 처리(Parallel Processing)
    

## 1.3 스레드, 스레드풀을 사용한 멀티 스레드 프로그래밍

### 1.3.1 Thread 클래스를 사용하는 방법과 한계

- 1.3.1.1 Thread 클래스를 사용해 스레드 다루기
    
    (오래 걸리는 작업이 별도 스레드에서 실행되도록) Thread 클래스를 상속하는 클래스를 만들기
    

### 사용자 스레드와 데몬 스레드

JVM은 스레드를 사용자 스레드와 데몬 스레드로 구분한다.

사용자 스레드 : 우선도가 높은 스레드

데몬 스레드: 우선도가 낮은 스레드

JVM 프로세스가 종료되는 시점은 우선도가 높은 사용자 스레드가 모두 종료될 때

데몬 스레드는 중요한 스레드가 아니기 때문에 강제 종료되더라도 프로세스가 정상 종료 됨

- 1.3.1.2 Thread 클래스를 직접 다루는 방법의 한계
    1. Thread는 생성 비용이 비싸기 때문에 매번 새로운 스레드를 생성하는 것은 성능적으로 좋지 않음
    2. 프로그램의 복잡성이 증가하며 실수로 인한 오류나 메모리 누수(memory leak)을 발생시킬 가능성이 증가
    

→ 한 번 생성한 스레드를 간편하게 재사용할 수 있어야하고 스레드 관리를 미리 구축한 시스템에서 책임질 수 있게 해야 함

### 1.3.2 Executor 프레임웍을 통해 스레드풀 사용하기

- 등장 배경 : 개발자가 스레드를 직접 관리하는 문제를 해결하고 생성된 스레드의 재사용성을 높이려고 등장
- 스레드풀 : 스레드의 집합
- Excutor 프레임웍 : 스레드풀을 관리하고 사용자로부터 요청받은 작업을 각 스레드에 할당하는 시스템

- 스레드풀을 미리 생성해 놓고 작업을 요청 받으면 쉬고 있는 스레드에 작업을 분배
    - 이 때 각 스레드가 작업을 끝내더라도 스레드를 종료하지 않고 다음 작업이 들어오면 재사용

→ 개발자는 스레드를 직접 다루거나 관리하지 않아도 되고, 스레드풀에 속한 스레드의 개수를 설정하고 해당 스레드풀을 관리하는 서비스에 작업을 제출하는 것 뿐

### 1.3.2.3 Executor 프레임웍의 의의와 한계

- 스레드 블로킹(Thread Blocking) : 스레드가 아무것도 하지 못하고 사용될 수 없는 상태에 있는 것
    - 스레드 블로킹을 발생시키는 원인들
        - 여러 스레드가 동기화 블록에 동시에 접근하는 경우, 하나의 스레드만 동기화 블록에 접근이 허용되기 때문에 발생할 수 있음
        - 뮤텍스, 세마포어로 인해 공유되는 자원에 접근할 수 있는 스레드가 제한되는 경우에도 발생할 수 있음

- Thread.sleep
    - 일정 시간 대기해야 할 때 사용하는 매우 유용한 함수지만, 스레드 블로킹을 일으키는 가장 대표적인 함수

 

### 1.3.3 이후의 멀티 스레드 프로그래밍과 한계

- CompletableFuture : 기존 Future 객체의 단점을 보완해 스레드 블로킹을 줄이고 작업을 체이닝 하는 기능 제공
- RxJava : 리액티브 프로그래밍 패러다임을 지원하고 결괏값을 데이터 스트림으로 처리함으로써 스레드 블로킹을 방지하고 작업이 실행되는 스레드풀을 손쉽게 전환할 수 있도록 만듬

## 1.4 기존 멀티 스레드 프로그래밍의 한계와 코루틴

- 기존 멀티 스레드 프로그래밍은 스레드 기반으로 작업한다는 한계를 가짐
    - 스레드는 생성 비용과 작업을 전환하는 비용이 비싸기 때문에 스레드가 아무 작업을 하지 못하게 되면 컴퓨터의 자원이 낭비됨
    - 하나의 스레드가 다른 스레드에서 수행하는 작업이 완료될 때까지 사용할 수 없게 되는 것을 스레드 블로킹 이라 함
    - 스레드 블로킹은 스레드라는 비싼 자원을 사용할 수 없게 만든다는 점에서 성능에 치명적인 영향을 줌

- 스레드 블로킹은 스레드 기반 작업을 하는 멀티 스레드 프로그래밍에서 피할 수 없는 문제
    - 콜백을 사용하거나 체이닝 함수를 사용하는 등의 방법을 통해 스레드 블로킹을 피할 수 있지만,
    
    작업이 많아지고 작업 간의 종속성이 복잡해질수록 스레드 블로킹을 피하기가 어려워짐
    

### 1.4.2 코루틴은 스레드 블로킹 문제를 어떻게 극복하는가?

- 코루틴은 작업 단위 코루틴을 통해 스레드 블로킹 문제를 해결함
- 작업 단위 코루틴은 스레드에서 작업 실행 도중 일시 중단할 수 있는 작업 단위
- 코루틴은 작업이 일시 중단되면 더 이상 스레드 사용이 필요하지 않으므로 스레드의 사용 권한을 양보하며, 양보된 스레드는 다른 작업을 실행하는데 사용할 수 있음
    
    일시 중단된 코루틴은 재개 시점에 다시 스레드에 할당돼 실행됨
    
- 코루틴이 경량 스레드 라고 불리는 이유는?
    - 코루틴을 만들어 코루틴 스케줄러에 넘기면 코루틴 스케줄러는 자신이 사용할 수 있는 스레드나 스레드풀에 해당 코루틴을 분배해 작업을 수행
    - 코루틴이 스레드를 사용하던 중에 필요가 없어지면 해당 스레드를 다른 코루틴이 쓸 수 있게 양보할 수 있어서 스레드 블로킹이 일어나지 않게 됨
    - 스레드에 코루틴을 뗐다 붙였다 할 수 있는 것과 같음
    - 코루틴은 자신의 스레드를 사용하지 않을 때 스레드 사용 권한을 반납함
    - 스레드 사용 권한을 반납하면, 해당 스레드에서는 다른 코루틴이 실행될 수 있음
    
- 즉, 코루틴은 작업 단위로서의 코루틴이 스레드를 사용하지 않을 때 스레드 사용 권한을 양보하는 방식으로 스레드 사용을 최적화하고 스레드가 블로킹되는 상황을 방지
    
    코루틴은 스레드에 비해 생성과 전환 비용이 적게 들고 스레드에 자유롭게 뗐다 붙였다 할 수 있어 작업을 생성하고 전환하는 데 필요한 리소스와 시간이 매우 줄어듬
    
- 코루틴의 다른 장점
    - 구조화된 동시성을 통해 비동기 작업을 안전하게 만듬
    - 예외 처리를 효과적으로 처리할 수 있도록 함
    - 코루틴이 실행 중인 스레드를 손쉽게 전환할 수 있도록 함
