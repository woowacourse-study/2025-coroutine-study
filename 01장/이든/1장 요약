# 📘 Chapter 1. 스레드 기반 작업의 한계와 코루틴의 등장

## 🧠 1.1 JVM 프로세스와 스레드

- JVM 프로세스는 기본적으로 메인 스레드를 단일 스레드로 사용하여 실행되며, 메인 스레드가 종료되면 프로세스도 종료됨
- 멀티 스레드 환경에서는 사용자 스레드가 여러 개일 경우, 메인 스레드에서 예외가 발생해도 프로세스가 강제 종료되지 않음

---

## 🧵 1.2 단일 스레드의 한계와 멀티 스레드 프로그래밍

### ⚠️ 1.2.1 단일 스레드 애플리케이션의 한계

- 하나의 스레드는 하나의 작업만 처리 가능 → 동시에 다른 작업을 수행하지 못함
- 메인 스레드 하나만 사용하면 오래 걸리는 작업 때문에 전체 응답성이 저하됨

> 단일 스레드만 사용하는 경우, 작업이 다른 작업에 의해 방해받거나 속도가 느려질 수 있음

### 🧶 1.2.2 멀티 스레드 프로그래밍을 통한 극복

- 멀티 스레드 프로그래밍: 여러 개의 스레드가 각각 다른 작업을 동시에 처리
- 안드로이드:
  - 메인 스레드 외의 백그라운드 스레드에서 작업 처리하여 UI 멈춤 방지
- 서버 사이드:
  - 작업을 나눠 병렬 실행하여 응답 속도 향상 (단, 작업 간 독립성 필요)

> ✅ 병렬 처리(Parallel Processing)로 성능 개선 가능

---

## ⚙️ 1.3 스레드와 스레드풀을 사용한 멀티 스레드 프로그래밍

### 🛠 1.3.1 `Thread` 클래스를 사용하는 방법과 한계

- 오래 걸리는 작업을 별도 스레드에서 실행하도록 `Thread` 클래스 상속

#### 🔄 사용자 스레드 vs 데몬 스레드

| 구분 | 설명 |
|------|------|
| 사용자 스레드 | 우선도 높음, 종료되어야 JVM이 종료됨 |
| 데몬 스레드 | 우선도 낮음, 사용자 스레드 종료 시 같이 종료됨 |

#### ❌ 한계

1. 스레드 생성 비용이 높아 성능 저하
2. 복잡성 증가 → 실수, 메모리 누수 위험

> ✅ 스레드를 재사용할 수 있는 시스템이 필요

---

### 🚀 1.3.2 `Executor` 프레임워크와 스레드풀

- 등장 배경: 스레드 직접 관리 문제 해결, 재사용성 확보
- `Executor` 프레임워크:
  - 스레드풀을 관리하고 작업을 적절한 스레드에 할당
- 스레드풀:
  - 미리 생성된 스레드 집합
  - 작업 완료 후에도 종료되지 않고 재사용됨

> 개발자는 스레드 개수 설정과 작업 제출만 담당

---

### ⚠️ 1.3.2.3 Executor 프레임워크의 한계

- **스레드 블로킹(Thread Blocking)**: 스레드가 아무 작업도 못 하고 멈춰있는 상태

#### 블로킹 원인

- 동기화 블록 접근 충돌
- 뮤텍스, 세마포어에 의한 자원 제한
- `Thread.sleep()` 등의 대기 함수

---

### 🔄 1.3.3 이후의 멀티 스레드 프로그래밍

- **`CompletableFuture`**: 작업 체이닝, 블로킹 감소
- **RxJava**: 데이터 스트림 기반 리액티브 프로그래밍 → 블로킹 최소화

---

## 🌀 1.4 기존 멀티 스레드 프로그래밍의 한계와 코루틴

### 🚧 기존 방식의 한계

- 스레드는 생성·전환 비용이 높고, 사용하지 않더라도 자원을 차지함
- **스레드 블로킹**은 자원 낭비와 성능 저하를 초래

> 작업이 많고 종속성이 복잡할수록 블로킹 회피가 어려워짐

---

### 💡 1.4.2 코루틴이 블로킹을 어떻게 극복하는가?

- 코루틴은 스레드 기반이 아닌 **작업 단위 기반**
- **작업 일시 중단 시 스레드 사용 권한을 반납** → 다른 코루틴이 스레드 사용 가능
- 재개 시 다시 스레드에 할당됨

#### ✨ 코루틴 = 경량 스레드

- 코루틴 스케줄러가 스레드에 코루틴을 **자유롭게 붙였다 떼었다**
- 스레드 블로킹 없이 자원 사용 최적화 가능

---

### 🌟 코루틴의 장점

- ✅ **비동기 작업의 안전성 확보** (구조화된 동시성)
- ✅ **효과적인 예외 처리**
- ✅ **스레드 전환이 쉬움**
- ✅ **작업 생성 및 전환 비용 최소화**

---

> 📌 **요약:** 코루틴은 기존 멀티 스레드 방식의 블로킹 문제를 해결하며, 자원 사용 최적화와 응답성 향상, 코드 가독성 모두를 개선하는 현대적인 비동기 프로그래밍 방식입니다.
