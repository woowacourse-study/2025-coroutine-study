# Chapter 5. async와 Deferred

- launch 코루틴 빌더를 통해 생성되는 코루틴은 기본적으로 작업 실행 후 결과를 반환하지 않음
- 코루틴 라이브러리는 비동기 작업으로부터 결과를 수신해야 하는 경우를 위해 async 코루틴 빌더를 통해 코루틴으로부터 결괏값을 수신받을 수 있도록 함
- launch 함수를 사용하면 결괏값이 없는 코루틴 객체인 Job이 반환되는 것과 다르게 async 함수를 사용하면 결괏값이 있는 코루틴 객체인 Deferred가 반환되며, Deferred 객체를 통해 코루틴으로부터 결괏값을 수신할 수 있음

## 5.1 async 사용해 결괏값 수신하기

### 5.1.1 async 사용해 Deferred 만들기

- launch와 async가 다른 점은 launch는 코루틴이 결괏값을 직접 반환할 수 없는 반면 async는 코루틴이 결괏값을 직접 반환할 수 있다는 점
- launch 코루틴 빌더는 코루틴에서 결괏값이 반환되지 않기 때문에 Job 객체를 반환하는데 async 코루틴 빌더는 코루틴에서 결괏값을 담아 반환하기 위해 Deffered<T> 타입의 객체를 반환함

- Deferred는 Job과 같이 코루틴을 추상화한 객체지만 코루틴으로부터 생성된 결괏값을 감싸는 기능을 추가로 가지며, 이 결괏값의 타입은 제네릭 타입인 T로 표현됨
- Deferred의 제네릭 타입을 지정하기 위해서는 Deferred에 명시적으로 타입을 설정하거나 async 블록의 반환값으로 반환할 결괏값을 설정하면 됨

### 5.1.2 await를 사용한 결괏값 수신

- Deferred 객체는 미래의 어느 시점에 결괏값이 반환될 수 있음을 표현하는 코루틴 객체
- 코루틴이 실행 완료될 때 결괏값이 반환되므로 언제 결괏값이 반환될 지 정확히 알 수 없으며, 만약 결괏값이 필요하다면 결괏값이 수신될 때까지 대기해야 함

- Deferred 객체는 결괏값 수신의 대기를 위해 await 함수를 제공
- await 함수는 await의 대상이 된 Deferred 코루틴이 실행 완료될 때까지 await 함수를 호출한 코루틴을 일시 중단하며, Deferred 코루틴이 실행 완료되면 결괏값을 반환하고 호출부의 코루틴을 재개함
- Deferred 객체의 await 함수는 코루틴이 실행 완료될 때까지 호출부의 코루틴을 일시 중단한다는 점에서 Job 객체의 join 함수와 매우 유사하게 동작

## 5.2 Deferred는 특수한 형태의 Job

- Deferred 객체는 Job 객체의 특수한 형태로 Deferred 인터페이스는 Job 인터페이스의 서브타입으로 선언된 인터페이스
- Deferred 객체는 Job 객체의 일종
- Deferred 인터페이스는 Job 인터페이스의 서브타입 이므로 Job 객체의 모든 함수와 프로퍼티를 사용할 수 있음
- 즉, Deferred 객체는 결괏값을 반환하는 기능이 추가된 Job 객체이며, Job 객체의 모든 함수와 변수를 사용할 수 있음.
    - 때문에 Deferred 객체는 특수한 형태의 Job 이라고 불림

## 5.3 복수의 코루틴으로부터 결괏값 수신하기

- 여러 비동기 작업으로부터 결괏값을 반환받아 병합해야 하는 경우가 생기면, 복수의 코루틴을 생성해 결괏값을 취합해야 함

### 5.3.1 await를 사용해 복수의 코루틴으로부터 결괏값 수신하기

- await 함수의 호출 시점에 따라 코루틴이 순차적으로 처리될 수 있고 동시에 처리될 수도 있다는 것을 이해하고, 코루틴이 동시에 실행될 수 있도록 만들어 코루틴의 성능을 최대한 끌어내야 함
- 각 코루틴이 동시에 실행될 수 있도록 만드는 것은 코루틴의 성능 측면에서 매우 중요

### 5.3.2 awaitAll을 사용한 결괏값 수신

- awaitAll 함수는 가변 인자로 Deferred 타입의 객체를 받아 인자로 받은 모든 Deferred 코루틴으로부터 결과가 수신될 때까지 호출부의 코루틴을 일시 중단한 후 결과가 모두 수신되면 Deferred 코루틴들로부터 수신한 결괏값들을 List로 만들어 반환하고 호출부의 코루틴을 재개함
- e.g) 콘서트 관람객을 등록받은 사이트가 10개 였다면 ? awaitAll()함수를 사용하여 결괏값을 수신

### 5.3.3 컬렉션에 대해 awaitAll 사용하기

- awaitAll 함수를 Collection 인터페이스에 대한 확장 함수로도 제공

## 5.4 withContext

### 5.4.1 withContext로 async-await 대체하기

- withContext : `withContext` 가 호출되면 함수의 인자로 설정된 `CoroutineContext` 객체를 사용해 `block` 람다식을 실행하고 결과를 반환

```kotlin
public suspend fun <T> withContext(
    context: CoroutineContext,
    block: suspend CoroutineScope.() -> T
): T
```

- async-await : async 함수를 호출해 Deferred 객체를 만들고, Deferred 객체에 대해 await 함수를 호출

```kotlin
fun main() = runBlocking<Unit> {
    val networkDeferred = Deferred<String> = async(Dispatchers.IO) {
        delay(1000L)
        return@async "Dummy Response"
    }
    val result = networkDeferred.await() // networkDeferred로부터 결괏값이 반환될 때
    println(result)
}

// withContext
fun main() = runBlocking<Unit> {
    val result: String = withContext(Dispatchers.IO) {
        delay(1000L)
        return@withContext "Dummy Response"
    }
    print(result)
}
```

- async 함수를 호출한 후 연속적으로 await 함수를 호출해 결괏값 수신을 대기하는 코드
- withContext 함수를 사용해 async-await 쌍을 깔끔하게 만들수 있음

### 5.4.2 withContext의 동작 방식

- withContext 함수는 겉보기에 async와 await를 연속적으로 호출하는 것과 비슷하게 동작하지만 내부적으로 다르게 동작
- async-await 쌍은 새로운 코루틴을 생성해 작업을 처리하지만 withContext 함수는 실행 중이던 코루틴을 그대로 유지한 채로 코루틴의 실행 환경만 변경해 작업을 처리함
- withContext 함수는 새로운 코루틴을 만드는 대신 기존의 코루틴에서 CoroutineContext 객체만 바꿔서 실행됨

- 즉, withContext를 호출하면 코루틴이 유지된 채로 코루틴을 실행하는 스레드만 변경되기 때문에 동기적으로 실행되는것
    - async-await 쌍을 사용하면 새로운 코루틴을 만들지만 await 함수를 통해 순차 처리가 돼 동기적으로 실행 되는것

### 5.4.2.1 Context Switching

- withContext 함수가 호출되면 실행 중인 코루틴의 실행 환경이 withContext 함수의 context 인자 값으로 변경돼 실행됨
- withContext 함수는 함수의 block 람다식이 실행되는 동안 코루틴의 실행 환경을 변경시킴

### 5.4.3 withContext 사용 시 주의점

- withContext 함수는 새로운 코루틴을 만들지 않기 때문에 하나의 코루틴에서 withContext 함수가 여러번 호출되면 순차적으로 실행됨
- 복수의 독립적인 작업이 병렬로 실행돼야 하는 상황에 withContext를 사용할 경우 성능에 문제를 일으킬 수 있음
