# async와 Deferred 
> 코루틴의 결과값을 수신 받을 수 있는 코루틴 빌더

## async - await를 사용해 코루틴으로부터 결괏값 수신하기
> async는 결과를 반환하는 코루틴을 만들기 위한 코루틴 빌더이다.  
> 내부적으로 Deferred<T> 타입을 반환하며, 결과가 준비될 때까지 await()로 기다릴 수 있다.

```kotlin
fun main() = runBlocking<Unit> {
    // 비동기 작업을 백그라운드 스레드(IO 디스패처)에서 실행
    val networkDeferred: Deferred<String> = async(Dispatchers.IO) {
        delay(1000) // 네트워크 통신을 흉내 내는 지연
        "Dummy Response" // 결과값
    }

    // networkDeferred로부터 결과값이 반환될 때까지 runBlocking은 일시 중단된다
    val result = networkDeferred.await()

    // 결과 출력
    println(result) // 출력: Dummy Response
}
```
위 코드에서 확인하면 networkDeferred가 반환될 때까지 runBlocking이 일시 중단되는 것을 볼 수 있다.

### Deferred
> async 코루틴 빌더가 반환하는 객체

```kotlin
public interface Deferred<out T> : Job{
  public suspend fun await(): T
}
```
위와 같이 Deferred는 Job을 상속하여 만든 서브타입 인터페이스이며
앞서 사용한 await함수는 코루틴으로부터 결괏값을 반환받으려고 추가된 함수이다.

> 이 때문에 Deferred는 Job객체의 모든 메서드와 프로퍼티를 사용할 수 있다.

## await를 사용하여 복수의 코루틴으로부터 결괏값 수신하기
> 복수의 코루틴으로부터 시간을 잘 관리하는 방법을 알아간다.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking<Unit> {
    val startTime = System.currentTimeMillis() // 1. 시작 시간 기록

    // 2. 플랫폼1에서 등록한 관람객 목록을 가져오는 코루틴
    val participantDeferred1: Deferred<Array<String>> = async(Dispatchers.IO) {
        delay(1000L)
        arrayOf("James", "Jason")
    }

    // 3. 플랫폼2에서 등록한 관람객 목록을 가져오는 코루틴
    val participantDeferred2: Deferred<Array<String>> = async(Dispatchers.IO) {
        delay(1000L)
        arrayOf("Jenny")
    }

    // 4~5. 각 코루틴의 결과를 받아오기 (비동기 작업 병렬 실행 후, await 시점에 일시 중단)
    val participants1 = participantDeferred1.await()
    val participants2 = participantDeferred2.await()

    // 6. 결과 병합 및 출력
    val allParticipants = listOf(*participants1, *participants2)
    val elapsedTime = System.currentTimeMillis() - startTime
    println("[$elapsedTime ms] 참여자 목록: $allParticipants")
}
```
위 코드와 같이 코루틴을 동시에 처리를 하도록 해야지 async를 선언하기 전에 await를 해버리면  
동시에 처리되지 않고 순차적으로 처리되어 매우 비효율적이다.

## awaitAll을 사용한 결괏값 수신
> 가변인자로 Deferred 타입의 객체를 받아 결괏값을 수신한다.

## withContext

### withContext로 async - await 대체하기
> 간단히 async - await 쌍을 사용한다고 하면 withContext로 가독성 좋게 바꿀 수 있다.

```kotlin
fun main() = runBlocking<Unit> {
    // 비동기 작업을 백그라운드 스레드(IO 디스패처)에서 실행
    val result: String = withContext(Dispatchers.IO) {
        delay(1000) // 네트워크 통신을 흉내 내는 지연
        return@withContext "Dummy Response" // 결과값
    }
    // 결과 출력
    println(result) // 출력: Dummy Response
}
```
위에 async - await 구조를 다음과 같이 간략하게 줄일 수 있게 된다.

### withContext 동작 방식
> withContext는 async와 await와는 다르게 코루틴을 새로 생성하지 않고 코루틴의 실행 환경만 변경해 작업을 처리한다.
