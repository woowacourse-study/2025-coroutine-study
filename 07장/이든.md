# Chapter 7. 구조화된 동시성

- 구조화된 동시성의 원칙
    - 비동기 작업을 구조화함으로써 비동기 프로그래밍을 보다 안정적이고 예측할 수 있게 만드는 원칙
    - 비동기 작업인 코루틴을 부모-자식 관계로 구조화함으로써 코루틴이 보다 안전하게 관리되고 제어될 수 있도록 함

- 코루틴을 부모-자식 관꼐로 구조화하는 방법
    - 부모 코루틴을 만드는 코루틴 빌더의 람다식 속에서 새로운 코루틴 빌더 호출
    
    ```kotlin
    fun main() = runBlocking<Unit> {
    	launch { //부모 코루틴
    		launch { //자식 코루틴
    				println("자식 코루틴 실행")
    		}
    	}
    }
    ```
    

- 구조화된 코루틴의 특징
    - 부모 코루틴은 실행 환경이 자식 코루틴에게 상속됨
    - 작업을 제어하는 데 사용
    - 부모 코루틴이 취소되면 자식 코루틴도 취소됨
    - 부모 코루틴은 자식 코루틴이 완료될 때까지 대기
    - CoroutineScope를 사용해 코루틴이 실행되는 범위를 제한할 수 있음

## 7.1 실행 환경 상속

### 7.1.1 부모 코루틴의 실행 환경 상속

- 부모 코루틴이 자식 코루틴을 생성하면 부모 코루틴의 CoroutineContext가 자식 코루틴에게 전달됨

### 7.1.2 실행 환경 덮어씌우기

- 부모 코루틴의 모든 실행 환경이 항상 자식 코루틴에게 상속되지는 않음

```kotlin
package org.example.section7

import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.launch
import kotlinx.coroutines.newSingleThreadContext
import kotlinx.coroutines.runBlocking

fun main() =
    runBlocking<Unit> {
        val coroutineContext = newSingleThreadContext("MyThread") + CoroutineName("ParentCoroutine")
        launch(coroutineContext) {
            // 부모 코루틴
            println("${Thread.currentThread().name} 부모 코루틴 실행")
            launch(CoroutineName("ChildCoroutine")) {
                // 자식 코루틴
                println("${Thread.currentThread().name} 자식 코루틴 실행")
            }
        }
    }

// MyThread @ParentCoroutine#2 부모 코루틴 실행
// MyThread @ChildCoroutine#3 자식 코루틴 실행
```

- 자식 코루틴을 생성하는 코루틴 빌더 함수로 새로운 CoroutineContext 객체가 전달되면 부모 코루틴에게서 전달받은 CoroutineContext 구성 요소들은 자식 코루틴 빌더 함수로 전달된 CoroutineContext 객체의 구성 요소들로 덮어씌워짐
- 다른 CoroutineContext 구성 요소들과 다르게 Job 객체는 상속되지 않고 코루틴 빌더가 호출되면 새롭게 생성됨

### 7.1.3 상속되지 않는 Job

- launch나 async를 포함한 모든 코루틴 빌더 함수는 호출 때마다 Job 객체를 새롭게 생성
- 코루틴 제어에 Job 객체가 필요한데 Job 객체를 부모 코루틴으로부터 상속받게 되면 개별 코루틴의 제어가 어려워지기 때문
- 코루틴 빌더를 통해 생성된 코루틴들은 서로 다른 Job을 가짐

```kotlin
fun main() =
    runBlocking<Unit> {
        // 부모 코루틴 생성
        val runBlockingJob = coroutineContext[Job]
        println("${Thread.currentThread().name} 부모 코루틴")
        launch(coroutineContext) {
            val launchJob = coroutineContext[Job]
            println("${Thread.currentThread().name} 자식 코루틴")
            if (runBlockingJob == launchJob) {
                println("runBlocking으로 생성된 Job과 launch로 생성된 Job이 동일합니다.")
            } else {
                println("runBlocking으로 생성된 Jobrhk launch로 생성된 Job이 다릅니다.")
            }
        }
    }
    
// main @coroutine#1 부모 코루틴
// main @coroutine#2 자식 코루틴
// runBlocking으로 생성된 Jobrhk launch로 생성된 Job이 다름
```

- 서로 다른 Job 객체를 가지지만, 자식 코루틴이 부모 코루틴으로부터 전달받은 Job 객체는 코루틴을 구조화 하는데 사용됨

### 7.1.4 구조화에 사용되는 Job

- 코루틴 빌더가 호출되면 Job 객체는 새롭게 생성되지만, 생성된 Job 객체는 내부에 정의된 parent 프로퍼티를 통해 부모 코루틴의 Job 객체에 대한 참조를 가짐
- 부모 코루틴의 Job 객체는 Sequence 타입의 children 프로퍼티를 통해 자식 코루틴의 Job에 대한 참조를 가져 자식 코루틴의 Job 객체와 부모 코루틴의 Job 객체는 양방향 참조를 가짐

| Job 프로퍼티 | 타입 | 설명 |
| --- | --- | --- |
| parent | Job? | 코루틴은 부모 코루틴이 없을 수 있고, 부모 코루틴이 있더라도 최대 하나이다. |
| children | Sequence<Job> | 하나의 코루틴이 복수의 자식 코루틴을 가질 수 있다. |
- 부모 코루틴이 없는 최상위에 정의된 코루틴은 루트 코루틴, 루트 코루틴의 Job 객체는 parent 프로퍼티의 값으로 null을 가짐

```kotlin
fun main() =
    runBlocking<Unit> {
        val parentJob = coroutineContext[Job]
        launch {
            val childJob = coroutineContext[Job]
            println("1. 부모 코루틴과 자식 코루틴의 Job은 같은가? ${parentJob == childJob}")
            println("2. 자식 코루틴의 Job이 가지고 있는 parent는 부모 코루니의 Job인가? ${childJob?.parent == parentJob}")
            println("3. 부모 코루틴의 Job은 자식 코루틴의 Job에 대한 참조를 가지는가? ${parentJob?.children?.contains(childJob)}")
        }
    }

1. 부모 코루틴과 자식 코루틴의 Job은 같은가? false
2. 자식 코루틴의 Job이 가지고 있는 parent는 부모 코루니의 Job인가? true
3. 부모 코루틴의 Job은 자식 코루틴의 Job에 대한 참조를 가지는가? true

```

## 7.2 코루틴의 구조화와 작업 제어

- 코루틴의 구조화는 하나의 큰 비동기 작업을 작은 비동기 작업으로 나눌 때 일어남
- 코루틴을 구조화하는 가장 중요한 이유는 코루틴을 안전하게 관리하고 제어하기 위함

- 구조화된 코루틴은 안전하게 제어되기 위해 몇 가지 특성을 가짐
1. 코루틴으로 취소가 요청되면 자식 코루틴으로 전파된다
2. 부모 코루틴은 모든 자식 코루틴이 실행 완료돼야 완료될 수 있다

### 7.2.1 취소의 전파

- 코루틴은 자식 코루틴으로 취소를 전파하는 특성을 갖기 때문에 특정 코루틴이 취소되면 하위의 모든 코루틴이 취소됨
- 특정 코루틴에 취소가 요청되면 취소는 자식 코루틴 방향으로만 전파되며, 부모 코루틴으로는 취소가 전파되지 않음
- 자식 코루틴으로만 취소가 전파되는 이유는 자식 코루틴이 부모 코루틴 작업의 일부이기 때문

### 7.2.2 부모 코루틴의 자식 코루틴에 대한 완료 의존성

- 부모 코루틴은 모든 자식 코루틴이 실행 완료돼야 완료될 수 있음
- 코루틴의 구조화는 큰 작업을 연관된 여러 작은 작업으로 나누는 방식으로 이뤄지는데 작은 작업이 모두 완료돼야 큰 작업이 완료될 수 있기 때문
    
    → 부모 코루틴이 자식 코루틴에 대해 완료 의존성을 가짐
    

```kotlin
package org.example.section7

import kotlinx.coroutines.*
import section5.code1.getElapsedTime

fun main() =
    runBlocking<Unit> {
        val startTime = System.currentTimeMillis()
        val parentJob =
            launch {
                launch {
                    delay(1000)
                    println("[${getElapsedTime(startTime)}] 자식 코루틴 실행 완료")
                }
                println("[${getElapsedTime(startTime)}] 부모 코루틴이 실행하는 마지막 코드")
            }
        // 코루틴이 실행 완료되거나 취소 완료됐을 때 실행되는 콜백을 등록하는 함수
        parentJob.invokeOnCompletion {
            println("[${getElapsedTime(startTime)}] 부모 코루틴 실행 완료")
        }
    }

[지난 시간 : 3ms] 부모 코루틴이 실행하는 마지막 코드
[지난 시간 : 1019ms] 자식 코루틴 실행 완료
[지난 시간 : 1020ms] 부모 코루틴 실행 완료
```

### 7.2.2.1 실행 완료 중 상태

- 부모 코루틴이 마지막 코드를 실행한 시점부터 자식 코루틴의 실행 완료를 기다릴 때까지의 상태
- ‘실행 완료 중’ 상태란 부모 코루틴의 모든 코드가 실행됐지만 자식 코루틴이 실행중인 경우 부모 코루틴이 갖는 상태를 말함
- 부모 코루틴은 더 이상 실행할 코드가 없더라도 자식 코루틴들이 모두 완료될 때까지 실행 완료될 수없어 ‘실행 완료 중’ 상태에 머뭄
- ‘실행 완료 중’ 상태의 부모 코루틴은 자식 코루틴들이 모두 실행 완료되면 자동으로 ‘실행 완료’ 상태로 바뀜

### 7.2.2.2 실행 완료 중 상태의 Job 상태 값

```kotlin
fun main() =
    runBlocking<Unit> {
        val startTime = System.currentTimeMillis()
        val parentJob =
            launch { 
                launch {
                    delay(1000)
                    println("[${getElapsedTime(startTime)}] 자식 코루틴 실행 완료")
                }
                println("[${getElapsedTime(startTime)}] 부모 코루틴이 실행하는 마지막 코드")
            }
        parentJob.invokeOnCompletion {
            println("[${getElapsedTime(startTime)}] 부모 코루틴 실행 완료")
        }
        delay(500L)
        printlnJobState(parentJob)
    }

//[지난 시간: 6ms] 부모 코루틴이 실행하는 마지막 코드
Job state
isActive >> true
isCancelled >> false
isCompleted >> false
[지난 시간:1023ms] 자식 코루틴 실행 완료
[지난 시간: 1023ms] 부모 코루틴 실행 완료

```

## 7.3 CoroutineScope 사용해 코루틴 관리하기

- CoroutineScope 객체는 자신의 범위 내에서 생성된 코루틴들에게 실행 환경을 제공하고 실행범위를 관리하는 역할을 함

### 7.3.1 CoroutineScope 생성하기

**7.3.1.1 CoroutineScope 인터페이스 구현을 통한 생성**

- CoroutineScope 인터페이스는 코루틴의 실행환경인 CoroutineContext를 가진 단순한 인터페이스로 이 인터페이스를 구현한 구체적인 클래스를 사용하면 CoroutineScope 객체를 생성할 수 있음

```kotlin
class CustomCoroutineScope : CoroutineScope {
	override val coroutineContext: CoroutineContext = Job() + newSingleThreadContext("CustomScopeThread")
}
```

```kotlin

fun main() =
    runBlocking<Unit> {
        val coroutineScope = CustomCoroutineScope()
        coroutineScope.launch {
            delay(100L)
            println("[${Thread.currentThread().name}] 코루틴 실행 완료")
        }
        Thread.sleep(1000L)
    }

class CustomCoroutineScope : CoroutineScope {
    override val coroutineContext: CoroutineContext = Job() + newSingleThreadContext("CustomScopeThread")
}

//[CustomScopeThread] 코루틴 실행 완료
```

**7.3.1.2 CoroutineScope 함수를 사용해 생성**

```kotlin
public fun CoroutineScope(context: CoroutineContext): CoroutineScope =
    CoroutineScope(if (context[Job] != null) context else context + Job())

fun main() {
    val coroutineScope = CoroutineScope(Dispatchers.IO)
    coroutineScope.launch {
        delay(100L)
        println("[${Thread.currentThread().name}] 코루틴 실행 완료")
    }
    Thread.sleep(1000L)
}

//[DefaultDispatcher-worker-1] 코루틴 실행 완료
```

- CoroutineScope 내부에서 실행되는 코루틴이 CoroutineScope로부터 코루틴 실행 환경인 CoroutineContext를 제공 받음

### 7.3.2 코루틴에게 실행 환경을 제공하는 CoroutineScope

**7.3.2.1 CoroutineScope가 코루틴에게 실행환경을 제공하는 방식**

- launch 함수가 호출되면
    - 수신 객체인 CoroutineScope로부터 CoroutineContext 객체를 제공받음
    - 제공받은 Coroutinecontext 객체에 launch 함수의 context 인자로 넘어온 CoroutineContext를 더함
    - 생성된 CoroutineContext에 코루틴 빌더 함수가 호출되어 새로운 Job객체를 더함
    - 이때 CoroutineContext를 통해 전달되는 Job 객체는 새로 생성되는 Job 객체의 부모 Job 객체가 됨

```kotlin
fun main() {
    val newScope = CoroutineScope(CoroutineName("MyCoroutine") + Dispatchers.IO)
    newScope.launch(CoroutineName("LaunchCoroutine")) {
        println(this.coroutineContext[CoroutineName])
        println(this.coroutineContext[CoroutineDispatcher])
        val launchJob = this.coroutineContext[Job]
        val newScopeJob = newScope.coroutineContext[Job]
        println("launchJob?.parent === newScopeJob >> ${launchJob?.parent === newScopeJob}")
    }
    Thread.sleep(1000L)
}

// CoroutineName(LaunchCoroutine)
// Dispatchers.IO
// launchJob?.parent === newScopeJob >> true

```

- 부모 코루틴이 자식 코루틴으로 실행 환경을 상속하는 방식과 완전히 동일
- 부모 코루틴의 CoroutineContext 객체를 가진 CoroutineScope 객체로부터 실행 환경을 상속받기 때문

### 7.3.3 CoroutineScope에 속한 코루틴의 범위

**7.3.3.1 CoroutineScope에 속한 코루틴의 범위**

- CoroutineScope 객체는 특정 범위의 코루틴들을 제어하는 역할을 함
- 코루틴 빌더 람다식에서 수신 객체로 제공되는 CoroutineScope 객체는 코루틴 빌더로 생성되는 코루틴과 람다식 내에서 CoroutineScope 객체를 사용해 실행되는 모든 코루틴을 포함함

**7.3.3.2 CoroutineScope를 새로 생성해 기존 CoroutineScope 범위에서 벗어나기**

- CoroutineScope을 새로 생성하면, 특정 코루틴을 기존의 CoroutineScope 범위에서 벗어나도록 만들 수 있음
- 코루틴은 Job 객체를 사용해 구조화되는데 CoroutineScope 함수를 사용해 새로운 CoroutineScope 객체를 생성하면 기존의 계층 구조를 따르지 않는 새로운 Job 객체가 생성되 새로운 계층 구조를 만들게 됨
- 일반적으로 Job 객체는 코루틴 빌더 함수를 통해 생성되는 코루틴을 제어하는 데 사용되지만 CoroutineScope 객체 또한 Job 객체를 통해 하위에 생성되는 코루틴을 제어함
    - 따라서 코루틴은 Job 객체를 갖지만 Job 객체가 꼭 코루틴이 아닐 수 있음

### 7.3.4 CoroutineScope 취소하기

- CoroutineScope 인터페이스는 확장 함수로 cancel 함수를 지원함
    - CoroutineScope 객체의 범위에 속한 모든 코루틴을 취소하는 함수

### 7.3.5 CoroutineScope 활성화 상태 확인하기

- CoroutineScope 객체가 현재 활성화돼 있는지 확인하는 isActive 확장 프로퍼티를 제공
- isActive 확장 프로퍼티는 Job 객체에 취소가 요청되면 false로 변경되기 때문에, 일시 중단 시점이 없는 코루틴을 안전하게 관리하는데 사용할 수 있음

 

## 7.4 구조화와 Job

### 7.4.1 runBlocking과 루트 Job

- runBlocking 함수를 호출해 코루틴이 생성되면 부모 Job이 없는 Job 객체를 생성함
- 부모 Job 객체가 없는 구조화의 시작점 역할을 하는 Job 객체를 루트 Job이라고 하고, 이 Job 객체에 의해 제어되는 코루틴을 루트 코루틴이라고 함

### 7.4.2 Job 구조화 깨기

**7.4.2.1 CoroutineScope 사용해 구조화 깨기**

CoroutineScope 생성 함수는 새로운 루트 Job을 가진 CoroutineContext를 생성한다.

- 모든 자식 코루틴들이 newScope 하위에서 실행되기 때문에 runBlocking 코루틴은 자식 코루틴이 없다.
- 아무것도 안 나오는 것은 newScope를 통해서, 코루틴의 구조화가 깨졌기 때문
- 이를 방지하기 위해서는 runBlocking 람다식 마지막에 일정 시간 동안 대기하는 코드를 넣어 메인 스레드 사용이 종료되는 것을 방지해야 함

**7.4.2.2 Job 사용해 구조화 깨기**

- Job 생성 함수로 새로운 루트 Job을 생성할 수 있음
- CoroutineScope 사용해 구조화 깨기와 유사하지만, 다른점은 newScope가 루트 Job을 포함했지만, 여기서는 newRootJob 자체가 루트 Job이 됨

### 7.4.3 Job 사용해 일부 코루틴만 취소되지 않게 만들기

- 새로 Job 객체를 생성해 계층 구조를 끊음으로써 일부 코루틴만 취소되지 않도록 설정할 수 있음

### 7.4.4 생성된 Job의 부모를 명시적으로 설정하기

- Job 생성함수는 부모 Job(parent)를 인자로 받을 수 있음
- 만약 parent 인자가 입력되지 않으면 parent가 null이 돼 루트 Job이 생성됨
- 만약 parent 인자가 입력되면, 해당 Job을 부모로 하는 Job이 생성됨
- Job 생성 함수에 parent 인자가 입력되지 않으면 parent가 null이 돼 루트 Job이 생성됨

### 7.4.5 생성된 Job은 자동으로 실행 완료되지 않는다

- Job 생성 함수에 parent 인자가 입력되면, 해당 Job을 부모로 하는 Job이 생성됨
- 생성 함수로 생성된 Job 객체는 자동으로 실행 완료되지 않기 때문에 명시적으로 complete 함수를 호출 해줘야 함
