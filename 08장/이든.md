# Chapter 8. 예외 처리

# 8.1 코루틴의 예외 전파

## 8.1.1 코루틴에서 예외가 전파되는 방식

- 코루틴 실행 도중에 예외 발생 시 예외가 발생한 코루틴은 취소되고 부모 코루틴으로 예외가 전파되며, 만약 부모 코루틴 에서도 예외가 처리되지 않으면 부모 코루틴도 취소되고 상위 코루틴으로 계속 전파되며 루트 코루틴까지 예외가 전파 될 수 있음
- 코루틴의 특성에 따라 해당 코루틴의 하위에 있는 모든 코루틴에게 취소가 전파되며, 따라서 예외가 적절히 처리되지 않아 루트 코루틴까지 예외가 전파되고 루트 코루틴이 취소되면 하위의 모든 코루틴에 취소가 전파됨
- 코루틴의 예외 전파를 제대로 막지 못해 코루틴이 취소되면 구조화된 코루틴이 모두 취소될 수 있음
- 만약 작은 작업에서 발생한 예외로 인해 큰 작업이 취소되면 애플리케이션의 안정성에 문제가 생길 수 있음
    - 이런 문제 해결을 위해 코루틴은 예외 전파를 제한하는 여러 장치를 가짐

# 8.2 예외 전파 제한

## 8.2.1 Job 객체를 사용한 예외 전파 제한

### 8.2.1.1 Job 객체를 사용해 예외 전파 제한하기

- 코루틴의 구조화를 깨는 것
- 코루틴은 자신의 부모 코루틴으로만 예외를 전파하는 특성을 가지므로 부모 코루틴과의 구조화를 깬다면 예외가 전파되지 않음
- 부모 코루틴과의 구조화를 깨는 방법: 새로운 Job 객체를 만들어 구조화를 깨고 싶은 코루틴을 연결하면 됨

```kotlin
fun main() = runBlocking<Unit> {
	launch(CoroutineName("Parent Coroutine")) {
		launch(CoroutineName("Coroutine1") + Job()) { // 새로운 Job객체를 만들어 Coroutine1에 연결
			launch(CoroutineName("Coroutine3")) {
				throw Exception("예외 발생")
				}
				delay(100L)
				println("[${Thread.currentThread().name}] 코루틴 실행")
				}
				launch(CoroutineName("Coroutine2")) {
					delay(100L)
					println("]${Thread.currentThread().name}] 코루틴 실행")
					}
				}
				delay(1000L)
			}
```

- Coroutine1 코루틴은 Job()을 사용해 새로운 Job 객체를 부모 Job으로 설정함으로써 Parent Coroutine 코루틴과의 구조화를 깸
- 따라서 Coroutine3 코루틴이 예외를 발생시켜 부모 코루틴인 Coroutine1 코루틴으로 예외를 전파하더라도 Coroutine1 코루틴은 Parent Coroutine 으로 예외를 전파하지 않음
- 대신 새로 만들어진 Job 객체에 예외를 전파함
- Parent Coroutine에는 예외가 전파되지 않아 Coroutine2 는 정상적으로 실행됨

### 8.2.1.2 Job 객체를 사용한 예외 전파 제한의 한계

- Job 객체를 생성해 코루틴의 구조화를 깨는 것은 예외 전파를 제한하는 것뿐만 아니라 취소 전파도 제한시킴
- 만약 작은 작업의 구조화가 깨진다면 큰 작업에 취소가 요청되더라도 작은 작업은 취소되지 않으며 이는 비동기 작업을 불안정하게 만듬
- 구조화를 깨지 않으면서 예외 전파를 할 수 없을까?
    - 코루틴 라이브러리는 구조화를 깨지 않으면서 예외 전파를 제한할 수 있도록 SupervisorJob 객체를 제공

## 8.2.2 SupervisorJob 객체를 사용한 예외 전파 제한

### 8.2.2.1 SupervisorJob 객체를 사용해 예외 전파 제한하기

- SupervisorJob 객체는 자식 코루틴으로부터 예외를 전파받지 않는 특수한 Job 객체로 하나의 자식 코루틴에서 발생한 예외가 다른 자식 코루틴에게 영향을 미치지 못하도록 만드는데 사용됨
- 일반적인 Job 객체는 자식 코루틴에서 예외가 발생하면 예외를 전파받아 취소되지만 SupervisorJob 객체는 예외를 전파받지 않아 취소되지 않음

```kotlin
public fun SupervisorJob(parent: Job? = null) : CompletableJob = SupervisorJobImpl(parent)
```

- SupervisorJob 생성 함수를 parent 인자 없이 사용하면 SupervisorJob 객체를 루트 Job 으로 만들 수 있으며, parent 인자로 Job 객체를 넘기면 부모 Job이 있는 SupervisorJob 객체를 만들 수 있음
- SupervisorJob 객체가 runBlocking이 호출돼 만들어진 Job 객체와의 구조화를 깸

### 8.2.2.2 코루틴의 구조화를 깨지 않고 SupervisorJob 사용하기

- 구조화를 깨지 않고 SupervisorJob을 사용하기 위해서는 SupervisorJob의 인자로 부모 Job 객체를 넘기면 됨

```kotlin
fun main(): Unit =
    runBlocking {
        // supervisorJob의 parent로 runBlocking으로 생성된 Job 객체 설정
        val supervisorJob = SupervisorJob(parent = this.coroutineContext[Job])
        launch(CoroutineName("Coroutine1") + supervisorJob) {
            launch(CoroutineName("Coroutine3")) {
                throw Exception("예외 발생")
            }
            delay(100L)
            println("[${Thread.currentThread().name}] 코루틴 실행")
        }
        launch(CoroutineName("Coroutine2") + supervisorJob) {
            delay(100L)
            println("[${Thread.currentThread().name}] 코루틴 실행")
        }
        supervisorJob.complete() // supervisorJob 완료 처리
    }
```

- this.coroutineContext[Job]을 사용해 runBlocking이 호출돼 만들어진 Job 객체를 가져오며, SupervisorJob 생성 함수의 인자로 이 Job 객체를 넘김
- 마지막에 supervisorJob.complete()을 실행해 supervisorJob에 대해 명시적으로 완료 처리

### 8.2.2.3 SupervisorJob을 CoroutineScope와 함께 사용하기

- CoroutineScope의 CoroutineContext에 SupervisorJob 객체가 설정된다면 CoroutineScope의 자식 코루틴에서 발생하는 예외가 다른 자식 코루틴으로 전파되지 않음
- CoroutineScope의 CoroutineContext에 SupervisorJob 객체를 설정하기 위해서는 CoroutineScope 생성 함수의 인자로 SupervisorJob()을 입력하면 됨

### 8.2.2.4 SupervisorJob을 사용할 때 흔히 하는 실수

- 예외 전파 방지를 위해 코루틴 빌더 함수의 context 인자에 SupervisorJob()을 넘기고, 코루틴 빌더 함수가 호출돼 생성되는 코루틴의 하위에 자식 코루틴들을 생성하는 것
- 문제가 생기는 이유
    - luanch 함수는 context 인자에 Job 객체가 입력될 경우 해당 Job 객체를 부모로 하는 새로운 Job 객체를 만들기 때문
    - 즉, launch 함수는 SupervisorJob()을 인자로 넘기면 SupervisorJob()을 통해 만들어지는 SupervisorJob 객체를 부모로 하는 새로운 Job 객체가 만들어짐
    

## 8.2.3 SupervisorScope를 사용한 예외 전파 제한

- SupervisorJob() 대안으로 SupervisorScope 함수를 사용
- SupervisorScope 함수는 SupervisorJob 객체르 ㄹ가진 CoroutineScope 객체를 생성하며, 이 SupervisorJob 객체는 SupervisorScope 함수를 호출한 코루틴의 Job 객체를 부모로 가짐
- 즉, SupervisorScope를 사용하면 복작한 설정 없이도 구조화를 깨지않고 예외 전파를 제한할 수 있음

# 8.3 CoroutineExceptionHandler를 사용한 예외 처리

- CoroutineExceptionHandler 생성
- CoroutineExceptionHandler 함수는 예외를 처리하는 람다식인 handler를 매개 변수로 가짐
- 처리되지 않은 예외만 처리하는 CoroutineExceptionHandler
- CoroutineExceptionHandler는 예외 전파를 제한하지 않음

# 8.4 try catch문을 사용한 예외 처리
