## 코루틴의 예외 전파 구조
+ 코루틴 실행 도중 예외가 밠갱하면 예외가 발생한 코뤁니이 취소되고 예외가 부모 코루틴으로 전파
+ 이 때, 예외를 전파 받은 부모 코루틴도 예외를 처리하지 않을시 취소되고, 그 사우이의 코루틴으로 예외가 전파
+ 코루틴이 예외를 전파 받이 취소되면 취소가 해당 코루틴의 하위에 있는 자식 코루틴들에 전파

<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/7f57cf7d-accb-48d9-b77d-9f073ef98633" />

> 이는 부모-자식 관계를 형성하는 코루틴의 구조화된 동시성 때문 !

## 코루틴의 구조화를 깨서 예외 전파를 제한하자
```
fun main() = runBlocking<Unit> {
    launch(CoroutineName("Parent Coroutine")) {
        
        // Job 객체를 변경해 구조화를 깬다 !
        launch(CoroutineName("Coroutine1") + Job()) {
            throw Exception("예외 발생")
        }
        delay(100L)
        println("[${Thread.currentThread().name}] 코루틴 실행")
    }

    launch(CoroutineName("Coroutine2")) {
        delay(100)
        println("[${Thread.currentThread().name}] 코루틴 실행")
    }

    delay(1000L)
}
```
## 하지만 코루틴의 구조화를 깨는 것은 매우 위험성을 동반한다 
#### 왜 ?
+ 코루틴의 구조화가 깨지만 예외 전파뿐만 아니라 취소 전파도 제한된다 <br/>
-> 만약 B 코루틴을 실행하기 위해 A 코루틴의 작업 결과가 필요할 때 구조화가 깨진 A 코루틴에서 예외가 발생해도 B 작업은 취소가 되지 않는다.
+ 코루틴이 구조화된 동시성을 채택한 이유에 위배된다<br/>
-> 코루틴은 외 구조화된 동시성을 채택했을까 ? 바로 예측 가능한 코드를 만들기 위함이다. 이러한 코루틴의 구조화된 동시성을 임의로 깰 경우 코드의 흐름을 예측하기 어려워질 수 있다.

## SupervisorJob을 사용한 예외 전파 제한
> SuperVisorJob : 자식 코루틴으로부터 예외를 전파 받지 않는 특수한 Job
> 예외를 전파 받지 않아 자식 코루틴에서 예외가 발생하더라도 취소되지 않음
```
/**
 * 활성 상태의 _supervisor_ Job 객체를 생성합니다.
 * supervisor Job의 자식들은 서로 독립적으로 실패할 수 있습니다.
 * 
 * 한 자식의 실패나 취소는 supervisor Job 자체를 실패하게 만들지 않으며,
 * 다른 자식들에게도 영향을 주지 않기 때문에,
 * supervisor는 자식들의 실패를 처리하기 위한 사용자 정의 정책을 구현할 수 있습니다:
 *
 * - [launch][CoroutineScope.launch]로 생성된 자식 Job의 실패는 컨텍스트의 [CoroutineExceptionHandler]를 통해 처리할 수 있습니다.
 * - [async][CoroutineScope.async]로 생성된 자식 Job의 실패는 반환된 Deferred 값에서 [Deferred.await]를 호출하여 처리할 수 있습니다.
 *
 * [parent] Job이 지정된 경우, 이 supervisor Job은 해당 [parent]의 자식 Job이 되며,
 * parent가 실패하거나 취소되면 supervisor Job도 함께 취소됩니다.
 * 이 경우 supervisor의 모든 자식들도 취소됩니다.
 */
@Suppress("FunctionName")
public fun SupervisorJob(parent: Job? = null) : CompletableJob = SupervisorJobImpl(parent)
```
<img width="622" height="434" alt="image" src="https://github.com/user-attachments/assets/aac16da4-cb3a-4a98-8700-32a8fad28cac" />

+ 하지만 이 방법도 supervisorJob의 부모로 runBlocking 코루틴과의 구조화를 깬다!!
+ 이를 해결하기 위해 supervisorJob의 인자로 runBlocking 코루틴의 Job을 넘기면 된다. 
<img width="617" height="430" alt="image" src="https://github.com/user-attachments/assets/f85babee-3092-470c-a569-aa996894da78" />

## supervisorScope을 사용한 예외 전파 제한
- `supervisorScope` : `Supervisorjob` 객체를 가진 `CoroutineScpose`
- `supervisorScope`를 통해 생성된 `SupervisorJob` 객체는 `supervisorScope` 함수를 호출한 코루틴을 부모로 가진다.
<img width="611" height="411" alt="image" src="https://github.com/user-attachments/assets/4113cd14-dac6-4cc6-8ad4-12486b8208ca" />

## CoroutineExceptionHandler를 사용한 예외 처리
- CoroutineContext의 구성 요소 중 하나로 처리되지 않은 예외만 처리한다.
- launch 코루틴으로 시작되는 코루틴 계층의 공통 예외 처리기로 동작

```
/**
 * 코루틴 컨텍스트에서 **잡히지 않은(uncaught)** 예외를 처리하기 위한 선택적 요소입니다.
 *
 * 일반적으로 잡히지 않은 예외는 [launch][CoroutineScope.launch] 빌더로 생성된 **루트** 코루틴에서만 발생합니다.  
 * 모든 **자식** 코루틴(다른 [Job]의 컨텍스트에서 생성된 코루틴)은 예외 처리를 부모 코루틴에 위임하고,  
 * 부모도 다시 그 부모에 위임하는 방식으로 루트까지 전달되므로,  
 * 이들의 컨텍스트에 설치된 `CoroutineExceptionHandler`는 사용되지 않습니다.  
 * [SupervisorJob]을 사용하는 코루틴은 예외를 부모로 전파하지 않으며 루트 코루틴처럼 취급됩니다.  
 * [async][CoroutineScope.async]로 생성된 코루틴은 항상 모든 예외를 스스로 잡아서  
 * 결과 [Deferred] 객체에 담기 때문에 잡히지 않은 예외가 발생하지 않습니다.
 *
 * ### 코루틴 예외 처리
 *
 * `CoroutineExceptionHandler`는 전역 "모든 예외 잡기" 동작을 위한 최후의 수단입니다.  
 * `CoroutineExceptionHandler` 안에서 예외를 복구(recover)할 수 없습니다.  
 * 핸들러가 호출될 때는 해당 예외로 인해 코루틴이 이미 완료된 상태입니다.  
 * 보통 이 핸들러는 예외 로깅, 오류 메시지 표시, 애플리케이션 종료 및/또는 재시작 등에 사용됩니다.
 *
 * 코드의 특정 부분에서 예외를 처리해야 한다면, 코루틴 내부에서 해당 코드 블록에
 * `try`/`catch`를 사용하는 것이 권장됩니다.  
 * 이렇게 하면 예외로 인한 코루틴의 완료를 방지하고(예외를 **잡은** 상태),  
 * 작업을 재시도하거나 다른 임의의 동작을 수행할 수 있습니다:
 *
 * ```
 * scope.launch { // 스코프에서 자식 코루틴 실행
 *     try {
 *          // 무언가 실행
 *     } catch (e: Throwable) {
 *          // 예외 처리
 *     }
 * }
 * ```
 *
 * ### 핸들러 없이 발생한 잡히지 않은 예외
 *
 * 핸들러가 설치되어 있지 않은 경우, 예외는 다음 방식으로 처리됩니다:
 * - 예외가 [CancellationException]인 경우 무시됩니다. 이 예외는 코루틴을 취소하는 데 사용됩니다.
 * - 그 외의 경우, 컨텍스트에 [Job]이 있다면 [Job.cancel]이 호출됩니다.
 * - 그마저도 없으면, 플랫폼별 방식으로 예외가 처리됩니다:
 *   - JVM: [ServiceLoader]로 찾은 모든 [CoroutineExceptionHandler] 인스턴스와  
 *     현재 스레드의 [Thread.uncaughtExceptionHandler]가 호출됩니다.
 *   - Native: 애플리케이션 전체가 해당 예외와 함께 종료됩니다.
 *   - JS: 예외가 Console API를 통해 로깅됩니다.
 *
 * [CoroutineExceptionHandler]는 임의의 스레드에서 호출될 수 있습니다.
 */
public interface CoroutineExceptionHandler : CoroutineContext.Element {
    /**
     * Key for [CoroutineExceptionHandler] instance in the coroutine context.
     */
    public companion object Key : CoroutineContext.Key<CoroutineExceptionHandler>

    /**
     * Handles uncaught [exception] in the given [context]. It is invoked
     * if coroutine has an uncaught exception.
     */
    public fun handleException(context: CoroutineContext, exception: Throwable)
}

```
