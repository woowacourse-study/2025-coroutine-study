# Chapter 9. 일시 중단 함수

# 9.1 일시 중단 함수와 코루틴

## 9.1.1 일시 중단 함수란 무엇인가?

- suspend fun 키워드로 선언되는 함수로 함수 내에 일시 중단 지점을 포함할 수 있는 특별한 기능
- 코루틴의 비동기 작업과 관련된 복잡한 코드들을 구조화하고 재사용할 수 있는 코드의 집합으로 만드는 데 사용됨
- 일반 함수와 용도가 같지만 다른 점은 일시 중단 지점을 포함하고 있음

## 9.1.2 일시 중단 함수는 코루틴이 아니다

- 일시 중단 함수는 코루틴 내부에서 실행되는 코드의 집합일 뿐, 코루틴이 아님
- 만약 일시 중단 함수를 코루틴처럼 사용하고 싶다면 일시 중단 함수를 코루틴 빌더로 감싸야 함

## 9.1.3 일시 중단 함수를 별도의 코루틴 상에서 실행하기

- 일시 중단 함수를 새로운 코루틴에서 실행하고 싶다면 일시 중단 함수를 코루틴 빌더 함수로 감싸면 됨

```kotlin
fun main() = runBlocking<Unit> {
	val startTime = System.currentTimeMillis()
	launch {
		delayAndPrintHelloWorld()
	}
	launch {
		delayAndPrintHelloWorld()
	}
	println(getElapsedTime(startTime))
}

//결과:
지난 시간 : 3ms
Hello World
Hello World
```

(307p)

# 9.2 일시 중단 함수의 사용

## 9.2.1 일시 중단 함수의 호출 가능 지점

- 일시 중단 함수는 내부에 일시 중단 가능 지점을 포함할 수 있기 때문에 일시 중단을 할 수 있는 곳에서만 호출 가능
- 일시 중단이 가능 한 지점
    - 코루틴 내부
    - 일시 중단 함수

### 9.2.1.1. 코루틴 내부에서 일시 중단 함수 호출하기

- 일시 중단 함수는 코루틴에서 호출될 수 있음

### 9.2.1.2 일시 중단 함수에서 다른 일시 중단 함수 호출하기

- 일시 중단 함수는 또 다른 일시 중단 함수에서 호출될 수 있음

## 9.2.2 일시 중단 함수에서 코루틴 실행하기

### 9.2.2.1 일시 중단 함수에서 코루틴 빌더 호출 시 생기는 문제

- launch나 async 같은 코루틴 빌더 함수는 CoroutineScope의 확장 함수로 선언돼 있기 때문에 아래의 코드와 같이 작성하면 오류가 발생 할 수 있음
    - 그 이유는 일시 중단 함수 내부에서는 일시 중단 함수를 호출한 코루틴의 CoroutineScope 객체에 접근할 수 없기 때문
- 일시 중단 함수에서 launch나 async 같은 코루틴 빌더 함수를 호출하기 위해서는 일시 중단 함수 내부에서 CoroutineScope 객체에 접근할 수 있도록 해야 함

### 9.2.2.2 coroutineScope 사용해 일시 중단 함수에서 코루틴 실행하기

- coroutineScope 일시 중단 함수를 사용하면 일시 중단 함수 내부에 새로운 coroutineScope 객체를 생성할 수 있음
- coroutineScope는 구조화를 깨지 않는 coroutineScope 객체를 생성하며, 생성된 coroutineScope 객체는 coroutineScope의 block 람다식에서 수신객체(this)로 접근 가능
    - 따라서 coroutineScope의 람다식에서는 코루틴 빌더 함수를 호출 가능
- 만약 DB에서 데이터를 조회화는 코루틴이 오류를 발생시키면 부모 코루틴으로 오류를 전파해 서버에서 데이터를 조회하는 코루틴까지 취소됨
    - 심지어 일시 중단 함수를 호출한 코루틴에까지 예외가 전파돼 호출부의 코루틴까지 모두 취소되어버림
    - 이 문제 해결을 위해 coroutineScope 일시 중단 함수 대신 supervisorScope 일시 중단 함수를 사용할 수 있음

### 9.2.2.3 supervisorScope 사용해 일시 중단 함수에서 코루틴 실행하기

- supervisorScope 일시 중단 함수를 사용해 예외 전파를 제한하면서 구조화를 깨지 않는 CoroutineScope 객체를 생성할 수 있음
- supervisorScope 일시 중단 함수는 Job 대신 SupervisorJob 객체를 생성하기 때문
    - 따라서 Deffered에서 예외가 발생하더라도 부모 코루틴으로 예외가 전파되지 않음
    - Deffered 객체는 await 함수 호출 시 추가로 예외를 노출하므로 try-catch 문을 통해 감싸 예외 발생 시 빈 결과가 반환 되도록 함
- supervisorScope 일시 중단 함수를 일시 중단 함수 내부에서 사용하면 구조화를 깨지 않는 새로운 CoroutineScope 객체도 만들 수 있고, CoroutineScope 객체 하위에서 실행되는 코루틴들의 예외 전파도 방지 가능
