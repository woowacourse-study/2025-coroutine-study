### 루틴(Routine) : 특정한 일을 하기 위한 일련의 명령 (함수, 메서드)
### 서브루틴(SubRoutine) : 함수(Routine) 내에서 함수가 호출될 경우 호출된 함수
- 한 번 실행되면 끝까지 실행된다.
- 루틴에 의해 서브루틴이 호출되면 루틴을 실행하던 스레드는 서브루틴을 실행하는데 사용돼 서브루틴의 실행이 완료될 때 까지 다른 작업을 할 수 없다.
```
fun routine(){
    routineA() // routineA는 routine 함수의 서브루틴
    routineB() // routineB는 routine 함수의 서브루틴
}

fun routineA(){
    routineB() // routineB는 routineA 함수의 서브루틴
}
fun routineB(){}
```

## 코루틴(Co-Routine) : 함께(Co) 샐행되는 루틴으로 서로간에 스레드 사용을 양보하며 함께 실행
- 코루틴의 스레드 양보
  - 코루틴은 작업 중간에 스레드의 사용이 필요 없어지면 스레드를 양보
  - 스레드를 양보하는 주체는 **코루틴 자기 자신**
  - 따라서, 스레드를 양보하기 위해서는 코루틴이 직접 스레드 양보를 위한 함수를 호출

### delay()
- 인자로 전달받은 시간동안 코루틴은 사용하던 스레드를 양보하고 일시 중단된다.
```
fun main() = runBlocking<Unit> { 
    val startTime = System.currentTimeMillis()
    repeat(10){ repeatTime ->
        launch { 
            delay(1000L)
            print("${getElapsedTime(startTime)} 코루틴$repeatTime 실행 완료")
        }
    }
}
```

 ### join & await
 - job의 join이나 async의 awit 함수가 호출되면 해당 함수를 호출한 코루틴은 스레드를 양보하고 대상이된 코루틴이 완료될 때까지 일시 중단된다.
 - 하나의 코루틴이 스레드를 양보하지 ㅇ낳으면 다른 코루틴은 스레드를 점유하지 못한다.
```
fun main() = runBlocking {
    val job = launch {
        println("1. launch 코루틴 작업 시작")
        delay(1000L)
        println("2. launch 코루틴 작업 완료")
    }

    println("3. runBlocking 코루틴이 곧 일시 중단 되고 메인 스레드가 양보됩니다.")
    job.join()
    println("4. runBlocking이 메인 스레드에 보내져 작업이 다시 재개됩니다.")
}
```
> 나의 예상 정답 : 1 -> 3 -> 2 -> 4
> 정답
> 
> 3. runBlocking 코루틴이 곧 일시 중단 되고 메인 스레드가 양보됩니다.
> 1. launch 코루틴 작업 시작
> 2. launch 코루틴 작업 완료
> 4. runBlocking이 메인 스레드에 보내져 작업이 다시 재개됩니다.

### 왜 3번이 가장 먼저 실행되는가 ?
+ 가장 먼저 `launch` 코루틴이 실행되 코루틴 디스패처에 의해 메인 스레드로 보내진다
+ 하지만 메인 스레드는 `runBlocking` 코루틴이 점유중이기 때문에 1번이 바로 출력되지 않는다.
+ 때문에 3번이 먼저 출력되며 `job.join` 함수를 통해 `runBlocking` 코루틴이 일시 중단되고 
+ 점유중인 스레드의 사용 권한을 `launch` 코루틴에게 양보해 1번이 실행된다.

### yield
- 단일 스레드만 사용하는 경우 명시적으로 `yield를` 사용해야 하는 경우가 종종 생긴다.
```
fun main() = runBlocking {
    val job = launch {
        while (this.isActive){
            println("작업 중")
        }
    }

    delay(100L)
    job.cancel()
}
```
> 나의 예상 정답 : while문이 무한 루프를 돈다
> 정답 : while문이 무한 루프를 돈다

### 왜 무한 루프를 도는가 ?
+ launch & await 같은 이유로 delay를 만나야 launch 코루틴이 실행된다.
+ 이 때 while 문 내부에서 코루틴의 사용 권한을 양보하지 않기 때문에 다시 메인 스레드로 돌아와 `cancel`을 호출하지 못한다.

### 코루틴의 실행 스레드는 고정이 아니다 !
+ 코루틴이 일시 중단된 후 재개되면 `CoroutineDispatcher` 객체는 재개된 코루틴을 다시 스레드에 보낸다.
+ 이 때, `CoroutineDispacher` 객체는 코루틴을 사용할 수 있는 스레드 중 하나에 보내기 때문에 코루틴이 재개된 후의 실행 스레드는 일시 중단되기 전의 스레드와 다를 수 있다.
