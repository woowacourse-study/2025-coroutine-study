## 코루틴의 예외 전파 구조
+ 코루틴 실행 도중 예외가 밠갱하면 예외가 발생한 코뤁니이 취소되고 예외가 부모 코루틴으로 전파
+ 이 때, 예외를 전파 받은 부모 코루틴도 예외를 처리하지 않을시 취소되고, 그 사우이의 코루틴으로 예외가 전파
+ 코루틴이 예외를 전파 받이 취소되면 취소가 해당 코루틴의 하위에 있는 자식 코루틴들에 전파

<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/7f57cf7d-accb-48d9-b77d-9f073ef98633" />

> 이는 부모-자식 관계를 형성하는 코루틴의 구조화된 동시성 때문 !

## 코루틴의 구조화를 깨서 예외 전파를 제한하자
```
fun main() = runBlocking<Unit> {
    launch(CoroutineName("Parent Coroutine")) {
        
        // Job 객체를 변경해 구조화를 깬다 !
        launch(CoroutineName("Coroutine1") + Job()) {
            throw Exception("예외 발생")
        }
        delay(100L)
        println("[${Thread.currentThread().name}] 코루틴 실행")
    }

    launch(CoroutineName("Coroutine2")) {
        delay(100)
        println("[${Thread.currentThread().name}] 코루틴 실행")
    }

    delay(1000L)
}
```
## 하지만 코루틴의 구조화를 깨는 것은 매우 위험성을 동반한다 
#### 왜 ?
+ 코루틴의 구조화가 깨지만 예외 전파뿐만 아니라 취소 전파도 제한된다 <br/>
-> 만약 B 코루틴을 실행하기 위해 A 코루틴의 작업 결과가 필요할 때 구조화가 깨진 A 코루틴에서 예외가 발생해도 B 작업은 취소가 되지 않는다.
+ 코루틴이 구조화된 동시성을 채택한 이유에 위배된다<br/>
-> 코루틴은 외 구조화된 동시성을 채택했을까 ? 바로 예측 가능한 코드를 만들기 위함이다. 이러한 코루틴의 구조화된 동시성을 임의로 깰 경우 코드의 흐름을 예측하기 어려워질 수 있다.

## SupervisorJob을 사용한 예외 전파 제한
> SuperVisorJob : 자식 코루틴으로부터 예외를 전파 받지 않는 특수한 Job
> 예외를 전파 받지 않아 자식 코루틴에서 예외가 발생하더라도 취소되지 않음
```
/**
 * 활성 상태의 _supervisor_ Job 객체를 생성합니다.
 * supervisor Job의 자식들은 서로 독립적으로 실패할 수 있습니다.
 * 
 * 한 자식의 실패나 취소는 supervisor Job 자체를 실패하게 만들지 않으며,
 * 다른 자식들에게도 영향을 주지 않기 때문에,
 * supervisor는 자식들의 실패를 처리하기 위한 사용자 정의 정책을 구현할 수 있습니다:
 *
 * - [launch][CoroutineScope.launch]로 생성된 자식 Job의 실패는 컨텍스트의 [CoroutineExceptionHandler]를 통해 처리할 수 있습니다.
 * - [async][CoroutineScope.async]로 생성된 자식 Job의 실패는 반환된 Deferred 값에서 [Deferred.await]를 호출하여 처리할 수 있습니다.
 *
 * [parent] Job이 지정된 경우, 이 supervisor Job은 해당 [parent]의 자식 Job이 되며,
 * parent가 실패하거나 취소되면 supervisor Job도 함께 취소됩니다.
 * 이 경우 supervisor의 모든 자식들도 취소됩니다.
 */
@Suppress("FunctionName")
public fun SupervisorJob(parent: Job? = null) : CompletableJob = SupervisorJobImpl(parent)
```
<img width="622" height="434" alt="image" src="https://github.com/user-attachments/assets/aac16da4-cb3a-4a98-8700-32a8fad28cac" />

+ 하지만 이 방법도 supervisorJob의 부모로 runBlocking 코루틴과의 구조화를 깬다!!
+ 이를 해결하기 위해 supervisorJob의 인자로 runBlocking 코루틴의 Job을 넘기면 된다. 
<img width="617" height="430" alt="image" src="https://github.com/user-attachments/assets/f85babee-3092-470c-a569-aa996894da78" />

## supervisorScope을 사용한 예외 전파 제한
- `supervisorScope` : `Supervisorjob` 객체를 가진 `CoroutineScpose`
- `supervisorScope`를 통해 생성된 `SupervisorJob` 객체는 `supervisorScope` 함수를 호출한 코루틴을 부모로 가진다.
<img width="611" height="411" alt="image" src="https://github.com/user-attachments/assets/4113cd14-dac6-4cc6-8ad4-12486b8208ca" />

## CoroutineExceptionHandler를 사용한 예외 전파 제한
- CoroutineContext의 구성 요소 중 하나로 처리되지 않은 예외만 처리한다.
- launch 코루틴으로 시작되는 코루틴 계층의 공통 예외 처리기로 동작
